package java.sql;

import java.util.Properties;
import java.util.concurrent.Executor;


/**
 * @author 张攀钦
 */
public interface Connection extends Wrapper, AutoCloseable {


    /**
     * 创建语句执行器去执行 sql
     */
    Statement createStatement() throws SQLException;

    /**
     * 多次执行的 sql 可以使用 prepareStatement 优化
     */
    PreparedStatement prepareStatement(String sql) throws SQLException;

    /**
     * 调用数据库的存储过程
     */
    CallableStatement prepareCall(String sql) throws SQLException;


    String nativeSQL(String sql) throws SQLException;

    /**
     * 设置事务是否自动提交。
     * 没设置时默认自动提交
     */
    void setAutoCommit(boolean autoCommit) throws SQLException;

    /**
     * 返回链接是否是自动提交
     */
    boolean getAutoCommit() throws SQLException;

    /**
     * 提交事务
     */
    void commit() throws SQLException;

    /**
     * 回滚事务
     */
    void rollback() throws SQLException;

    /**
     * 释放此链接
     */
    @Override
    void close() throws SQLException;

    /**
     * 判断链接是否关闭
     */
    boolean isClosed() throws SQLException;

    //======================================================================
    // Advanced features:

    DatabaseMetaData getMetaData() throws SQLException;

    /**
     * 设置当前链接为只读
     */
    void setReadOnly(boolean readOnly) throws SQLException;

    /**
     * 判断当前链接是否是只读
     */
    boolean isReadOnly() throws SQLException;

    /**
     * 设置当前链接操作的那个数据库的名称
     */
    void setCatalog(String catalog) throws SQLException;

    /**
     * 获取当前链接操作的那个数据库
     */
    String getCatalog() throws SQLException;

    /**
     * 标识不支持事务
     */
    int TRANSACTION_NONE = 0;

    /**
     * 读未提交，可导致 脏读，不可重复读，幻读
     */
    int TRANSACTION_READ_UNCOMMITTED = 1;

    /**
     * 读已提交，可导致 不可重读，幻读
     */
    int TRANSACTION_READ_COMMITTED = 2;

    /**
     * 重复读，可导致幻读
     */
    int TRANSACTION_REPEATABLE_READ = 4;

    /**
     * 串行化，最安全的
     */
    int TRANSACTION_SERIALIZABLE = 8;

    /**
     * 设置事务的隔离级别
     */
    void setTransactionIsolation(int level) throws SQLException;

    /**
     * 获取事务的隔离级别
     */
    int getTransactionIsolation() throws SQLException;

    /**
     * 获取当前链接上的警告
     */
    SQLWarning getWarnings() throws SQLException;

    /**
     * Clears all warnings reported for this <code>Connection</code> object.
     * After a call to this method, the method <code>getWarnings</code>
     * returns <code>null</code> until a new warning is
     * reported for this <code>Connection</code> object.
     *
     * @throws SQLException SQLException if a database access error occurs
     *                      or this method is called on a closed connection
     */
    void clearWarnings() throws SQLException;


    //--------------------------JDBC 2.0-----------------------------
    Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException;

    PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException;

    CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException;


    java.util.Map<String, Class<?>> getTypeMap() throws SQLException;


    void setTypeMap(java.util.Map<String, Class<?>> map) throws SQLException;

    //--------------------------JDBC 3.0-----------------------------

    void setHoldability(int holdability) throws SQLException;


    int getHoldability() throws SQLException;

    /**
     * 创建一个没有名称的保存点
     */
    Savepoint setSavepoint() throws SQLException;


    /**
     * 在当前事务中创建一个带有名称的保存点
     */
    Savepoint setSavepoint(String name) throws SQLException;

    /**
     * 撤消保存点之后所有的操作
     */
    void rollback(Savepoint savepoint) throws SQLException;

    /**
     * 撤消当前保存点及之后的保存点
     */
    void releaseSavepoint(Savepoint savepoint) throws SQLException;

    Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException;

    PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException;

    CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException;

    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException;

    PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException;

    PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException;


    Clob createClob() throws SQLException;


    Blob createBlob() throws SQLException;


    NClob createNClob() throws SQLException;


    SQLXML createSQLXML() throws SQLException;


    boolean isValid(int timeout) throws SQLException;


    void setClientInfo(String name, String value) throws SQLClientInfoException;

    void setClientInfo(Properties properties) throws SQLClientInfoException;

    String getClientInfo(String name) throws SQLException;


    Properties getClientInfo() throws SQLException;

    Array createArrayOf(String typeName, Object[] elements) throws SQLException;


    Struct createStruct(String typeName, Object[] attributes) throws SQLException;

    //--------------------------JDBC 4.1 -----------------------------


    void setSchema(String schema) throws SQLException;

    /**
     * 
     */
    
    String getSchema() throws SQLException;

    /**
     * 关闭连接释放资源
     */
    void abort(Executor executor) throws SQLException;

    /**
     * 设置等待超时时间
     */
    void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException;


    /**
     * 获取超时链接的毫秒数，超时抛出异常 SQLException
     */
    int getNetworkTimeout() throws SQLException;
}
